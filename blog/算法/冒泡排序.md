### 冒泡排序

每次比较两个相邻的元素，如果顺序错误则交换，一趟结束只能将一个数归位，给入的数组有多长就需要循环多少趟

例如 [4, 2, 6, 3, 1] 按从大到小排序，则顺序为：

|  输入  |  4   |  2   |  6   |  3   |  1   |
| :----: | :--: | :--: | :--: | :--: | :--: |
| 第一趟 |  4   |  6   |  3   |  2   |  1   |
| 第二趟 |  6   |  4   |  3   |  1   |  1   |
| 第三趟 |  6   |  4   |  3   |  2   |  1   |
| 第四趟 |  6   |  4   |  3   |  2   |  1   |
| 第五趟 |  6   |  4   |  3   |  2   |  1   |

从右往左，每一趟确定一个最小值，第一趟是1，第二趟是2，第三趟是3，第四趟是4，第五趟是6，这样五趟完成以后，整个排序就结束了。

代码实现：

```
int[] list = {1, 3, 2, 6, 4, 7};
int value = list[0];
            
for (int i = 0; i < list.Length; i++){
    // Console.WriteLine(" i: " + list[i]);
    value = list[i];
    for (int j = 0; j < list.Length; j++){
        if(list[i] > list[j]) {
        	value = list[j];
        	list[j] = list[i];
        	list[i] = value;
    	}
	}
}
for (int i = 0; i < list.Length; i++){
    Console.WriteLine("index:{0}: {1} ", i, list[i]);  // 输出7，6，4，3，2，1
}
```



可以看出来，冒泡排序很明显的问题是：

1. for循环的嵌套，使得其时间复杂度为 $O(N^2)$
2. 有可能已经提前拍好序了，但是还是继续循环下去直至结束

