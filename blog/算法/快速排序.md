### 快速排序

快速排序采用二分法进行排序，先选择一个基数，这个基数一般是数组下标为0的数，然后从数组尾巴开始往前比较，如果存在一个数小于基数，则停止查找，然后从数组头部开始查找，如果存在一个数大于基数则停止查找，然后交换这两个数的位置。重复比较跟交换直到头尾两个位置重合，最后将基数与最终的交叉点的数字位置交换，表示一轮排序结束。


一轮结束并不代表这些数字已经排序完成，只表示以基数为中心，基数左边的数字必然小于基数，基数右边的必然大于基数，但是基数左边跟基数右边的数字并不一定是拍好的，这时就需要重新定义基数，分别对左边跟右边的数进行排序，如此反复，则最后到没有数字可以遍历时结束，此时，数组必然是有序的

可见，这是一个不断深入的相同的重复的操作，这种操作可以用递归来实现。

```
static void quickSort(int left, int right, int[] list){
    int i, j, temp;
    i = left;
    j = right;
    if(i > j) return;
    // Console.WriteLine(".....length: {0}-{1}", left, right);
    temp = list[left];
    while(i != j){                
         while(list[j] >= temp && i < j){
              j --;
         }
         while(list[i] <= temp && i < j){
              i ++;
         }
         if(i < j){
              int t = list[i];
              list[i] = list[j];
              list[j] = t;
         }
   }
   list[left] = list[i];
   list[i] = temp;

   string s = "";
   for (int k = 0; k < list.Length; k++){
        s += list[k];
        s += "_";
   }
   Console.WriteLine(".......i: {0}:{1}:{2}:{3}", s, left, right, temp);

   quickSort(left, i - 1, list);
   quickSort(i+1, right, list);
}

static void Main(string[] args){
     int[] list = {1, 45, 4, 7};
     quickSort(0, list.Length - 1, list);
}

```

如上的代码，快速排序的过程为：（一行表示一次排序结束）

| 下标0 | 下标0 | 下标0 | 下标0 | left | right | temp基数 |
| ----- | ----- | ----- | ----- | ---- | ----- | -------- |
| 1     | 45    | 4     | 7     | 0    | 1     | 1        |
| 1     | 7     | 4     | 45    | 1    | 3     | 45       |
| 1     | 7     | 7     | 45    | 1    | 2     | 7        |
|       | 4     | 7     | 45    | 1    | 1     | 4        |

