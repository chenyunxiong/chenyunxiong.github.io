### 观察者模式（Observer）

观察者模式的主要作用是用于解耦，是一种一对多的关系。多个观察者同时监听一个数据或者对象状态，当这个数据或者对象状态变化的时候，通知所有的观察者，进而所有的观察者做出对应的响应。

举个例子，游戏中一般都有货币系统，当同时多个地方需要显示货币数量，而又不在一个页面，且又需要进行刷新的时候，这时候一个一个去通知刷新是很难受的，而且会有很严重的耦合。而观察者模式能完美的解决这个问题。

观察者模式有多种不同的实现方式，看项目或者个人需要。这里说两种实现方式：

#### 抽象模式

抽象模式多使用与框架中，比如PureMVC整个框架的消息机制就使用了抽象模式。

抽象模式通常需要一个中介，也就是一个控制类，它保存着所有的订阅者跟订阅者所对应的事件ID。然后定义一个抽象类或者接口，将需要的方法抽象进这个接口或者抽象类中，供其他类进行继承。继承者重写各自的接受消息的方法。

使用的时候，订阅者通过中介订阅事件，其他类告诉中介应该通知哪些消息，然后中介内部自动分发对应的订阅者。

```
namespace VSCode{
    interface IObserver    
    {
        void Receive();
    }

    class ObserverA : IObserver
    {
        public void Receive()
        {
            Console.WriteLine("A");
        }
    }

    class ObserverB : IObserver
    {
        public void Receive()
        {
            Console.WriteLine("B");
        }
    }

    class MessageCtrl{
        public static Dictionary<string, IObserver> observerDict = new Dictionary<string, IObserver>();
        public static void Add(string type, IObserver ob){
            if(!observerDict.ContainsKey(type)){
                observerDict.Add(type, ob);
            }
        }

        public static void Remove(string type, IObserver ob){
            if(observerDict.ContainsKey(type)){
                observerDict.Remove(type);
            }
        }

        public static void Dispatch(string type){
            if(observerDict.ContainsKey(type)){
                observerDict[type].Receive();
            }
        }

    }

    class Main{
        public void Create(){
        }
    }
}
```



#### 事件/委托模式

事件/委托类型则简单许多，因为事件跟委托本身就支持一对多的关系。

```
static int count = 0;
static int Count{
    set{
            count = value;
            Event_Currency_Count_Changed();
    }
}
    private static Action Event_Currency_Count_Changed;
    static void RefreshCurrencyImage(){
        Console.WriteLine("RefreshCurrencyImage");
    }

    static void RefreshCurrencyCount(){
        Console.WriteLine("RefreshCurrencyCount");
    }

    static void EventObserver(){
        Event_Currency_Count_Changed += RefreshCurrencyCount;
        Event_Currency_Count_Changed += RefreshCurrencyImage;

        Count = 10;
    }
```

Count 属性中直接调用了Event_Currency_Count_Changed 事件，在EventObserver中两个方法订阅了这个事件，当Count改变时，就会通知Event_Currency_Count_Changed，进而通知 RefreshCurrencyImage()、RefreshCurrencyCount()，这样金币数量改变的时候，就会刷新金币数量的显示跟金币图标的显示。这里只是做个示范，简单的刷新同一个类内的方法，更大的意义是其他类订阅这个事件，然后就可以刷新其他类的方法，以达到实现解耦的作用。

