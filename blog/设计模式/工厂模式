### 工厂模式（Factory）

都知道流水线是近代工业的重大突破，使得生产效率大幅度提高。工厂模式的作用也是如此。一般来说，我们平常用到某个类，直接new一个就可以了。但是特殊情况下，我们不确定需要哪个类，或者存在多个同类型的类比如任务、车、游戏中的基础数据类比如资源、道具等这些类的时候，就可能用到工厂模式。

它可以直接返回我们需要的类的实例，而不需要我们去考虑中间的各种转换跟弯弯，这些逻辑都写在了工厂内部，使用的时候直接传递一个或者多个具有唯一标识的信息，工厂就可以返回我们需要的类的实例。这就是其方便之处。

工厂模式同样也存在多种实现方式，最简单的就是直接通过逻辑判断然后返回需要的类：

#### 简单工厂

```
static void Factory(string type){
    if(type == "prop"){
        // create prop 创建道具
    }
    else if(type == "resource"){
        // create resource //创建资源
    }

    switch(type){
        case "prop":
        {
            // create prop 创建道具
        }
        break;
        case "resources":
        {
            // create resource //创建资源
        }
        break;
    }
}
```

简单工厂直接以逻辑判断做处理，直接生成对应的实例，当然，之际情况下，不会使用string作为判断依据，每个游戏中都有对应的数据类的唯一标识符，通过标识符辨别需要生成哪种类型的实例。

#### 接口/抽象类

```
namespace VSCode{
    interface IFactor
    {
        void Name();
        void GetType();
    }

    class FactoryA : IFactor
    {
        void IFactor.GetType()
        {
            throw new System.NotImplementedException();
        }

        void IFactor.Name()
        {
            throw new System.NotImplementedException();
        }
    }

    class FactoryB : IFactor
    {
        void IFactor.GetType()
        {
            throw new System.NotImplementedException();
        }

        void IFactor.Name()
        {
            throw new System.NotImplementedException();
        }
    }

    class NullFactory : IFactor
    {
        public void Name()
        {
            throw new System.NotImplementedException();
        }

        void IFactor.GetType()
        {
            throw new System.NotImplementedException();
        }
    }

    class  Factory {
        public static IFactor FactoryCreateItem(string type){            
            if(type == "A"){
                return new FactoryA();
            }
            else if(type == "B")
            {
                return new FactoryB();
            }
            else
            {
                return new NullFactory();
            }
        }
    }
}
```

接口/抽象类则复杂一些，因为生成都都是同一类型的不同类，因此，直接将相同的部分抽象到接口或者抽象类中，然后不同的类型继承并重写。然后将创建方式写在一块，使用的时候，直接调用并传入需要的参数就可以获得需要的类的实例